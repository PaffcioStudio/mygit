#!/usr/bin/env bash

# =============================================================================
# ğŸ§  mygit - Klient REST API (Bash)
# Wersja: 2.2.0 (Pretty UI)
# =============================================================================

# Konfiguracja
CONFIG_DIR="$HOME/.config/mygit"
CONFIG_FILE="$CONFIG_DIR/config.json"
REPO_NAME=$(basename "$PWD")

# Kolory i Style
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# --- FUNKCJE POMOCNICZE ---

log_info() { echo -e "${BLUE}â„¹ï¸  mygit:${NC} $1" >&2; }
log_success() { echo -e "${GREEN}âœ… mygit:${NC} $1" >&2; }
log_warning() { echo -e "${YELLOW}âš ï¸  mygit:${NC} $1" >&2; }
log_error() { echo -e "${RED}âŒ mygit:${NC} $1" >&2; }

check_deps() {
    local missing=0
    for cmd in curl jq zip unzip; do
        if ! command -v $cmd >/dev/null 2>&1; then
            log_error "Brak wymaganej komendy: $cmd"
            missing=1
        fi
    done
    if [ $missing -eq 1 ]; then
        echo "Zainstaluj brakujÄ…ce narzÄ™dzia (np. sudo apt install curl jq zip unzip)"
        exit 1
    fi
}

load_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        log_error "Brak pliku konfiguracji: $CONFIG_FILE"
        echo "Uruchom ponownie skrypt install.sh lub utwÃ³rz plik rÄ™cznie."
        exit 1
    fi
    BACKEND_URL=$(jq -r '.backend.baseUrl' "$CONFIG_FILE")
    if [ "$BACKEND_URL" == "null" ] || [ -z "$BACKEND_URL" ]; then
        log_error "BÅ‚Ä™dna konfiguracja: brak backend.baseUrl"
        exit 1
    fi
}

format_bytes() {
    local bytes=$1
    if [ -z "$bytes" ] || [ "$bytes" == "null" ]; then echo "0 B"; return; fi
    if [ $bytes -lt 1024 ]; then echo "${bytes} B";
    elif [ $bytes -lt 1048576 ]; then echo "$(echo "scale=2; $bytes/1024" | bc) KB";
    else echo "$(echo "scale=2; $bytes/1048576" | bc) MB"; fi
}

# Funkcja do Å‚adnego wyÅ›wietlania pojedynczego wpisu (uÅ¼ywana w log i search)
print_commit_entry() {
    local file="$1"
    local date="$2"
    local msg="$3"
    local size="$4"

    # Czyszczenie daty (z formatu ISO na czytelniejszy: YYYY-MM-DD HH:MM)
    # Usuwa 'T', usuwa sekundy i milisekundy
    local clean_date=$(echo "$date" | sed 's/T/ /; s/\..*//' | cut -d: -f1,2)

    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "${CYAN}ğŸ“¦ ${file}${NC}"
    echo -e "   ${DIM}ğŸ“… ${clean_date}      ğŸ’¾ $(format_bytes $size)${NC}"
    echo -e "   ${BOLD}ğŸ’­ ${msg}${NC}"
}

# --- KOMENDY ---

cmd_init() {
    local desc="${1:-Repozytorium $REPO_NAME}"
    log_info "Inicjalizacja repozytorium '$REPO_NAME' na serwerze..."
    local json=$(jq -n --arg name "$REPO_NAME" --arg desc "$desc" '{name: $name, description: $desc}')
    local response=$(curl -s -X POST -H "Content-Type: application/json" -d "$json" "$BACKEND_URL/api/repos")
    if echo "$response" | grep -q "error"; then
        log_error "BÅ‚Ä…d: $(echo "$response" | jq -r '.error')"
        exit 1
    fi
    log_success "Repozytorium utworzone!"
}

cmd_save() {
    local msg="${1:-snapshot}"
    log_info "Przygotowywanie snapshotu dla '$REPO_NAME'..."
    local check=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/api/repos/$REPO_NAME/info")
    if [ "$check" != "200" ]; then
        log_error "Repozytorium nie istnieje na serwerze. UÅ¼yj najpierw: mygit init"
        exit 1
    fi

    local exclude_args="-x \"*.git*\" \"node_modules/*\""
    if [ -f ".mygitignore" ]; then
        while IFS= read -r pattern || [ -n "$pattern" ]; do
            pattern=$(echo "$pattern" | sed 's/#.*$//' | tr -d '[:space:]')
            if [ -n "$pattern" ]; then
                exclude_args="$exclude_args \"$pattern*\""
            fi
        done < ".mygitignore"
    fi

    log_info "Pakowanie i wysyÅ‚anie..."
    local encoded_msg=$(jq -nr --arg v "$msg" '$v|@uri')
    
    # ZIP -> PIPE -> CURL
    eval "zip -r -q - . $exclude_args" | \
    curl -s -X POST --data-binary @- \
         "$BACKEND_URL/api/repos/$REPO_NAME/snapshot?message=$encoded_msg" \
         -H "Content-Type: application/zip" > /tmp/mygit_response.json

    local response=$(cat /tmp/mygit_response.json)
    if echo "$response" | grep -q "error"; then
        log_error "BÅ‚Ä…d uploadu: $(echo "$response" | jq -r '.error')"
        rm -f /tmp/mygit_response.json
        exit 1
    fi

    local file=$(echo "$response" | jq -r '.file')
    local size=$(echo "$response" | jq -r '.size')
    log_success "Zapisano snapshot: $file ($(format_bytes $size))"
    rm -f /tmp/mygit_response.json
}

cmd_list() {
    log_info "Lista repozytoriÃ³w na $BACKEND_URL:"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    curl -s "$BACKEND_URL/api/repos" | jq -r '.[] | "\(.id)|\(.description // "brak opisu")"' | while IFS='|' read -r id desc; do
        echo -e "${CYAN}ğŸ“¦ ${id}${NC}"
        echo -e "   ${DIM}${desc}${NC}"
    done
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

cmd_log() {
    log_info "Historia snapshotÃ³w dla '$REPO_NAME':"
    local response=$(curl -s "$BACKEND_URL/api/repos/$REPO_NAME/history")
    if echo "$response" | grep -q "error"; then
        echo "Brak historii lub repozytorium nie istnieje."
        return
    fi
    
    # UÅ¼ywamy jq do sformatowania danych w jednÄ… liniÄ™ oddzielonÄ… pipe'ami, a potem czytamy w pÄ™tli
    echo "$response" | jq -r '.[] | "\(.file)|\(.date)|\(.message)|\(.size)"' | head -n 15 | while IFS='|' read -r file date msg size; do
        print_commit_entry "$file" "$date" "$msg" "$size"
    done
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

cmd_status() {
    local response=$(curl -s "$BACKEND_URL/api/repos/$REPO_NAME/info")
    if echo "$response" | grep -q "error"; then
        log_error "Repozytorium nie istnieje."
        return
    fi
    local desc=$(echo "$response" | jq -r '.description')
    local count=$(echo "$response" | jq -r '.commitCount')
    local total=$(echo "$response" | jq -r '.totalSize')
    local last=$(echo "$response" | jq -r '.lastCommit.file // "brak"')
    
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "${MAGENTA}ğŸ“Š STATUS: ${BOLD}$REPO_NAME${NC}"
    echo -e "   ğŸ“ Opis:       ${WHITE}$desc${NC}"
    echo -e "   ğŸ“¦ Snapshoty:  ${WHITE}$count${NC}"
    echo -e "   ğŸ’¾ Rozmiar:    ${WHITE}$(format_bytes $total)${NC}"
    echo -e "   ğŸ•’ Ostatni:    ${CYAN}$last${NC}"
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

cmd_comment() {
    local comment="$1"
    if [ -z "$comment" ]; then log_error "Podaj treÅ›Ä‡ komentarza"; exit 1; fi
    local json=$(jq -n --arg desc "$comment" '{description: $desc}')
    curl -s -X POST -H "Content-Type: application/json" -d "$json" "$BACKEND_URL/api/repos/$REPO_NAME/comment" > /dev/null
    log_success "Zaktualizowano opis."
}

cmd_delete() {
    local target="$1"
    if [ -z "$target" ]; then log_error "Podaj nazwÄ™ pliku snapshotu do usuniÄ™cia"; exit 1; fi
    curl -s -X DELETE "$BACKEND_URL/api/repos/$REPO_NAME/commit/$target" > /dev/null
    log_success "UsuniÄ™to snapshot $target"
}

cmd_get() {
    local target="$1"
    local force=0
    # ObsÅ‚uga flag (np. -f)
    if [[ "$1" == "-f" ]] || [[ "$1" == "--force" ]]; then force=1; shift; target="$1"; fi
    if [[ "$2" == "-f" ]] || [[ "$2" == "--force" ]]; then force=1; fi

    local fetch_repo="$REPO_NAME"
    local fetch_file=""
    
    # Parsowanie targetu (repo@plik lub samo repo)
    if [[ "$target" == *@* ]]; then
        fetch_repo="${target%@*}"
        fetch_file="${target#*@}"
    elif [ -n "$target" ] && [[ "$target" != -* ]]; then
        fetch_repo="$target"
    fi

    log_info "Pobieranie z $fetch_repo..."
    local url
    if [ -n "$fetch_file" ]; then
        url="$BACKEND_URL/api/repos/$fetch_repo/snapshot/$fetch_file"
    else
        url="$BACKEND_URL/api/repos/$fetch_repo/latest"
    fi
    
    # 1. Pobranie informacji o pliku
    local info=$(curl -s "$url")
    if echo "$info" | grep -q "error"; then
        log_error "BÅ‚Ä…d: $(echo "$info" | jq -r '.error')"
        exit 1
    fi
    local zip_name=$(echo "$info" | jq -r '.file')
    local zip_size=$(echo "$info" | jq -r '.size')
    
    log_info "Znaleziono: $zip_name ($(format_bytes $zip_size))"
    
    # 2. Pobranie pliku ZIP
    local tmp_zip=$(mktemp)
    # curl -# wyÅ›wietla prosty pasek postÄ™pu
    curl -# -o "$tmp_zip" "$BACKEND_URL/api/repos/$fetch_repo/download/$zip_name"
    
    # 3. Backup (jeÅ›li nie uÅ¼yto --force)
    if [ $force -eq 0 ]; then
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local backup_dir=".mygit_backup_$timestamp"
        
        # Sprawdzamy czy sÄ… jakiekolwiek pliki do backupu (pomijajÄ…c .git, node_modules i sam backup)
        if [ "$(ls -A . 2>/dev/null)" ]; then
            log_warning "Robienie szybkiego backupu do: $backup_dir..."
            mkdir -p "$backup_dir"
            
            # Kopiujemy wszystko oprÃ³cz katalogÃ³w backupu i tmp (prosty rsync lub cp)
            # UÅ¼ywamy rsync jeÅ›li jest (szybszy), lub cp
            if command -v rsync >/dev/null 2>&1; then
                rsync -a --exclude=".mygit_backup_*" --exclude="node_modules" --exclude=".git" . "$backup_dir"
            else
                # Fallback dla cp (mniej precyzyjny przy exclude, ale dziaÅ‚a)
                cp -r * "$backup_dir" 2>/dev/null || true
            fi
        fi
    fi

    # 4. Rozpakowanie
    log_info "ğŸ“¦ Rozpakowywanie..."
    
    # Flaga -o (overwrite) wymusza nadpisanie bez pytaÅ„
    # Flaga -q (quiet) wycisza listÄ™ plikÃ³w
    unzip -o -q "$tmp_zip" -d .
    
    rm "$tmp_zip"
    
    if [ $force -eq 0 ] && [ -d "$backup_dir" ]; then
        log_success "Pobrano snapshot. Backup zmian lokalnych: $backup_dir"
    else
        log_success "Pobrano i nadpisano pliki."
    fi
}

# --- NOWE KOMENDY ---

cmd_delete_repo() {
    echo -e "${RED}âš ï¸  UWAGA! To usunie CAÅE repozytorium '$REPO_NAME' z serwera i caÅ‚Ä… jego historiÄ™.${NC}"
    read -p "Czy na pewno chcesz kontynuowaÄ‡? (wpisz nazwÄ™ repozytorium, aby potwierdziÄ‡): " confirm
    
    if [ "$confirm" != "$REPO_NAME" ]; then
        log_info "Anulowano. Nazwa nie pasuje."
        exit 0
    fi
    
    local response=$(curl -s -X DELETE "$BACKEND_URL/api/repos/$REPO_NAME")
    if echo "$response" | grep -q "error"; then
        log_error "BÅ‚Ä…d: $(echo "$response" | jq -r '.error')"
    else
        log_success "Repozytorium $REPO_NAME zostaÅ‚o usuniÄ™te."
    fi
}

cmd_diff() {
    local target="$1"
    
    if [ -z "$target" ]; then
         local info=$(curl -s "$BACKEND_URL/api/repos/$REPO_NAME/latest")
         target=$(echo "$info" | jq -r '.file')
         if [ "$target" == "null" ]; then
            log_error "Brak snapshotÃ³w do porÃ³wnania."
            exit 1
         fi
    fi

    log_info "Pobieranie diff dla: $target (vs poprzedni)"
    local json=$(curl -s "$BACKEND_URL/api/repos/$REPO_NAME/diff/$target")
    
    if echo "$json" | grep -q "error"; then
        log_error "BÅ‚Ä…d diff: $(echo "$json" | jq -r '.error')"
        exit 1
    fi
    
    echo -e "\n${CYAN}--- Zmiany w $target ---${NC}"
    echo "$json" | jq -r '.added[]' | while read line; do echo -e "${GREEN}[+] $line${NC}"; done
    echo "$json" | jq -r '.removed[]' | while read line; do echo -e "${RED}[-] $line${NC}"; done
    echo "$json" | jq -r '.modified[]' | while read line; do echo -e "${YELLOW}[~] $line${NC}"; done
    
    local stats=$(echo "$json" | jq -r '.stats')
    echo -e "\n${MAGENTA}Statystyki:${NC} $(echo $stats | jq -r '"+\(.added)  -\(.removed)  ~\(.modified)"')"
}

cmd_cat() {
    local snapshot="$1"
    local filepath="$2"
    
    if [ -z "$snapshot" ] || [ -z "$filepath" ]; then
        log_error "UÅ¼ycie: mygit cat <snapshot_zip> <Å›cieÅ¼ka/do/pliku>"
        exit 1
    fi
    
    local encoded_path=$(jq -nr --arg v "$filepath" '$v|@uri')
    curl -s "$BACKEND_URL/api/repos/$REPO_NAME/file/$snapshot/$encoded_path"
}

cmd_config() {
    local key="$1"
    local value="$2"
    
    if [ -z "$key" ]; then
        echo -e "${CYAN}Obecna konfiguracja ($CONFIG_FILE):${NC}"
        cat "$CONFIG_FILE" | jq .
        return
    fi
    
    if [ -z "$value" ]; then
        jq -r ".$key" "$CONFIG_FILE"
    else
        local tmp=$(mktemp)
        jq --arg v "$value" ".$key = \$v" "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"
        log_success "Ustawiono $key = $value"
    fi
}

cmd_search() {
    local term="$1"
    if [ -z "$term" ]; then log_error "Podaj szukanÄ… frazÄ™"; exit 1; fi
    
    log_info "Szukanie '$term' w historii $REPO_NAME..."
    
    # UÅ¼ywamy tej samej Å‚adnej funkcji co w LOG
    curl -s "$BACKEND_URL/api/repos/$REPO_NAME/history" | \
    jq -r --arg term "$term" '.[] | select(.message | test($term; "i")) | "\(.file)|\(.date)|\(.message)|\(.size)"' | \
    while IFS='|' read -r file date msg size; do
        print_commit_entry "$file" "$date" "$msg" "$size"
    done
    echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}


# --- MAIN ---

check_deps
load_config

COMMAND="$1"
shift

case "$COMMAND" in
    init)        cmd_init "$*" ;;
    save|push)   cmd_save "$*" ;;
    get|pull)    cmd_get "$@" ;;
    list|repos)  cmd_list ;;
    status)      cmd_status ;;
    log|history) cmd_log ;;
    comment)     cmd_comment "$*" ;;
    delete)      cmd_delete "$1" ;;
    delete-repo) cmd_delete_repo ;;
    diff)        cmd_diff "$1" ;;
    cat)         cmd_cat "$1" "$2" ;;
    config)      cmd_config "$1" "$2" ;;
    search)      cmd_search "$1" ;;
    
    *)
        echo -e "${MAGENTA}ğŸ§  mygit v2.2 (Pretty UI)${NC}"
        echo "UÅ¼ycie: mygit <komenda>"
        echo "------------------------------------------------"
        echo "  init [opis]        - UtwÃ³rz repozytorium"
        echo "  save [msg]         - WyÅ›lij snapshot"
        echo "  get [repo]         - Pobierz snapshot"
        echo "  status             - Status obecnego repo"
        echo "  log                - Historia zmian"
        echo "------------------------------------------------"
        echo -e "${CYAN}  diff [snap]        - PokaÅ¼ zmiany w snapshocie${NC}"
        echo -e "${CYAN}  cat <snap> <plik>  - PokaÅ¼ zawartoÅ›Ä‡ pliku z historii${NC}"
        echo -e "${CYAN}  search \"fraza\"     - Szukaj w opisach${NC}"
        echo -e "${CYAN}  config [key val]   - ZarzÄ…dzaj ustawieniami${NC}"
        echo "------------------------------------------------"
        echo -e "${RED}  delete <file>      - UsuÅ„ jeden snapshot${NC}"
        echo -e "${RED}  delete-repo        - UsuÅ„ CAÅE repozytorium${NC}"
        exit 1
        ;;
esac